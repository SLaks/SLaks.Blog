---
title: "Subtleties of C# 5’s new [CallerMemberName]"
layout: "post"
permalink: "/2011/10/subtleties-of-c-5s-new-callermembername.html"
uuid: "5376149243877966549"
guid: "tag:blogger.com,1999:blog-4137132196361303955.post-5376149243877966549"
date: "2011-10-18 00:31:00"
updated: "2012-03-01 07:02:51"
description: 
blogger:
    siteid: "4137132196361303955"
    postid: "5376149243877966549"
    comments: "0"
categories: [design, .Net, caller-info-attributes, C# 5]
author: 
    name: "SLaks"
    url: "https://www.blogger.com/profile/10900687553232370750?rel=author"
    image: "https://2.bp.blogspot.com/_iWJc6lVY4ho/TQVnDlN8sLI/AAAAAAAAHIs/0-Us6Xpqbc0/s1600-R/7deca8ec973c3c0875e9a36e1e3e2c44%253Fs%253D32%2526d%253Didenticon%2526r%253DPG"
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
<p><strong>UPDATE</strong>: Now that the Visual Studio 11 beta has shipped with this feature implemented, I wrote a <a href="/2012/03/exploring-caller-info-attributes.html">separate blog post</a> exploring how it actually behaves in these corner cases.</p>  <p><a href="/2011/10/subtleties-of-c-5s-new-callerlinenumber.html">Last time</a>, I explored various pathological code samples in which the [CallerLineNumber] attribute does not have obvious behavior.&#160; This time, I’ll cover the last of these new <a href="/2011/10/subtleties-of-new-caller-info.html">caller info attributes</a>: [CallerMemberName].</p>  <p>The [CallerMemberName] attribute tells the compiler to insert the name of the containing member instead of a parameter’s default value.&#160; Unlike [CallerLineNumber] and [CallerFileName], this has no equivalent in C++; since the C / C++ versions of these features are in the preprocessor, they cannot be aware of member names.</p>  <p>Most calls to methods with optional parameters take place within a named method, so the behavior of this attribute is usually obvious.&#160; However, there are a couple of places where the exact method name is not so obvious.</p>  <p>If you call a [CallerMemberName] method inside a property or event accessor, what name should the compiler pass?&#160; Common sense indicates that it should pass the name of the property or event, since that’s the name you actually see in source code.&#160; That would also allow this attribute to be <a href="https://www.robfe.com/2011/09/raising-the-right-propertychanged-with-c-5s-caller-info-attributes/">used for raising PropertyChanged events</a>.&#160; However, this option doesn’t pass enough information, since it would not be possible to determine whether it was called from the getter or the setter.&#160; To expose the maximal amount of information, the compiler should pass the name of the actual method for the accessor – <code>get_Name</code> or <code>set_Name</code>.&#160; </p>  <p>I would assume that the compiler only passes the property name, since that is what most people would probably expect.</p>  <p>A less-trivial question arises when such a method is called from a constructor or static constructor.&#160; Should the compiler just pass the name of the class, since that’s what the member is named in source code? If so, there would be no way to distinguish between an instance constructor and a static constructor.&#160; Should the compiler pass the actual names of the CLR methods (<code>.ctor</code> and <code>.cctor</code>)?&#160; If so, there would be no way to tell the class name, which is worse.&#160; Should it pass both (<code>ClassName.ctor</code>)? That would expose the maximal amount of information, but wouldn’t match the behavior in other members, which does not include the class name.</p>  <p>On a related note, what about calls to <code>base</code> or <code>this</code> constructors that take [CallerMemberName] arguments? Is that considered part of the class’ constructor, even though the call is lexically scoped outside the constructor?&#160; If not, what should it pass?</p>  <p>A further related concern is field initializers. Since field initializers aren’t explicitly in any member, what should the compiler pass if you call a [CallerMemberName] method in a field initializer? I would assume that they’re treated like contructors (or static constructors for static field initializers)</p>  <p>I would assume that a call to a [CallerMemberName] method from within an anonymous method or LINQ query would use the name of the parent method.</p>  <p>The most interesting question concerns attributes.&#160; What should happen if you declare your own custom attribute that takes a [CallerMemberName] parameter, then apply the attribute somewhere without specifying the parameter?</p>  <p>If you place the attribute on a parameter, return value, or method, it would make sense for the compiler to pass the name of the method that the attribute was applied to.&#160; If you apply the attribute to a type, it might make sense to pass the name of that type.&#160; However, there is no obvious choice for attributes applied to a module or assembly.</p>  <p>I suspect that they instead chose to not pass these caller info in default parameters for attribute declarations, and to instead pass the parameters’ declared default values.&#160; If so, it would make sense to disallow caller info attributes in attribute constructor parameters.&#160; However, this would also prevent them from being used for attributes that are explicitly instantiated in normal code (eg, for global filters in MVC).</p>  <p><a href="/2011/10/caller-info-attributes-vs-stack-walking.html"><em>Next Time:</em> Caller Info Attributes vs. Stack Walking</a></p>  
</div>
{% endraw %}