---
title: "About .Net Events"
layout: "post"
permalink: "/2011/07/about-net-events.html"
uuid: "8241465683788933619"
guid: "tag:blogger.com,1999:blog-4137132196361303955.post-8241465683788933619"
date: "2011-07-29 02:14:00"
updated: "2011-07-29 22:38:04"
description: 
blogger:
    siteid: "4137132196361303955"
    postid: "8241465683788933619"
    comments: "0"
categories: [C#, events, .Net]
author: 
    name: "SLaks"
    url: "http://www.blogger.com/profile/10900687553232370750?rel=author"
    image: "http://2.bp.blogspot.com/_iWJc6lVY4ho/TQVnDlN8sLI/AAAAAAAAHIs/0-Us6Xpqbc0/s1600-R/7deca8ec973c3c0875e9a36e1e3e2c44%253Fs%253D32%2526d%253Didenticon%2526r%253DPG"
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
<p>A .Net event actually consists of a pair of <em>accessor methods</em> named <code>add_<em>EventName</em></code> and <code>remove_<em>EventName</em></code>.&#160; These functions each take a handler delegate, and are expected to add or remove that delegate from the list of event handlers.&#160; </p>  <p>In C#, writing <code>public event EventHandler EventName;</code> creates a <em><a href="http://msdn.microsoft.com/en-us/library/aa664455%28v=vs.71%29.aspx">field-like event</a></em>.&#160; The compiler will automatically generate a private backing field (also a delegate), along with thread-safe accessor methods that add and remove handlers from the backing field (like an <a href="http://msdn.microsoft.com/en-us/library/bb384054.aspx">auto-implemented property</a>).&#160; Within the class that declared the event, <code>EventName</code> refers to this private backing field.&#160; Thus, writing <code>EventName(...)</code> in the class calls this field and raises the event (if no handlers have been added, the field will be <code>null</code>).</p>  <p>You can also write custom event accessors to gain full control over how handlers are added to your events.&#160;&#160; For example, this event will store and trigger handlers in reverse order:</p>  <pre class="brush: csharp;">void Main()
{
    ReversedEvent += delegate { Console.WriteLine(1); };
    ReversedEvent += delegate { Console.WriteLine(2); };
    ReversedEvent += delegate { Console.WriteLine(3); };

    OnReversedEvent();
}

protected void OnReversedEvent() {
    if (reversedEvent != null)
        reversedEvent(this, EventArgs.Empty);
}

private EventHandler reversedEvent;
public event EventHandler ReversedEvent {
    add {
        reversedEvent = value + reversedEvent;
    }
    remove {
        reversedEvent -= value;
    }
}</pre>

<p>This <code>add</code> accessor uses the non-commutative delegate addition operator to prepend each new handler to the delegate field containing the existing handlers.&#160; The raiser method simply calls the combined delegate in the private field. (which is <code>null</code> if there aren’t any handlers)</p>

<p>Note that this code is not thread-safe.&#160; If two threads add a handler at the same time, both of them will read the original storage field, add their respective handlers to create a new delegate instance, then write this new delegate back to the field.&#160; The thread that writes back to the field last will overwrite the changes made by the other thread, since it never saw the other thread’s handler (this is the same reason that <code>x += y</code> is not thread-safe).&#160; The accessors generated by the compiler are threadsafe, either by using <code>lock(this)</code> (C# 3 or earlier) or a lock-free threadsafe implementation (C# 4).&#160; For more details, see <a href="http://www.google.com/search?q=site%3Amsdn.com+%22Events+get+a+little+overhaul+in+C%23+4%22">this series of blog posts</a>.</p>

<p>This example is rather useless.&#160; However, there are better reasons to create custom event accessors. WinForms controls store their events in a special <a href="http://msdn.microsoft.com/en-us/library/system.componentmodel.eventhandlerlist.aspx"><code>EventHandlerList</code> class</a> to save memory.&#160; WPF controls create events using the <a href="http://msdn.microsoft.com/en-us/library/ms742806.aspx">Routed Event system</a>, and store handlers in special storage in DependencyObject.&#160; Custom event accessors can also be used to perform validation or <a href="http://stackoverflow.com/q/6748320/34397">logging</a>.</p>  
</div>
{% endraw %}