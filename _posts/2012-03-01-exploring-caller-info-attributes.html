---
title: "Exploring Caller Info Attributes"
layout: "post"
permalink: "/2012/03/exploring-caller-info-attributes.html"
uuid: "8396183916466972553"
guid: "tag:blogger.com,1999:blog-4137132196361303955.post-8396183916466972553"
date: "2012-03-01 06:57:00"
updated: "2012-03-01 06:57:54"
description: 
blogger:
    siteid: "4137132196361303955"
    postid: "8396183916466972553"
    comments: "1"
categories: [C#, .Net, caller-info-attributes, C# 5]
author: 
    name: "SLaks"
    url: "http://www.blogger.com/profile/10900687553232370750?rel=author"
    image: "http://2.bp.blogspot.com/_iWJc6lVY4ho/TQVnDlN8sLI/AAAAAAAAHIs/0-Us6Xpqbc0/s1600-R/7deca8ec973c3c0875e9a36e1e3e2c44%253Fs%253D32%2526d%253Didenticon%2526r%253DPG"
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
<p>Last year, Microsoft announced a simple new feature in C# 5: <a href="http://msdn.microsoft.com/en-us/library/hh534540%28VS.110%29.aspx">Caller Info Attributes</a>.&#160; These attributes let you to create methods with optional parameters and tell the compiler to pass the caller’s filepath, line number, or member name instead of the parameter’s default value.&#160; This allows you to create logging methods that automatically know where they’re being called.</p>  <p>When the feature was announced, I wrote a <a href="/2011/10/subtleties-of-new-caller-info.html">couple</a> of <a href="/2011/10/subtleties-of-c-5s-new-callerlinenumber.html">blog</a> <a href="/2011/10/subtleties-of-c-5s-new-callermembername.html">posts</a> that delved into some of the corner cases of the new feature.&#160; At the time, there was no public implementation, so they were pure conjecture.</p>  <p>This morning, Microsoft released the beta of <a href="http://www.microsoft.com/visualstudio/11/en-us">Visual Studio 11</a>, which is the first public build supporting these attributes.&#160; Now, I can finally test my theories.&#160; Here are the results:</p>  <p>Although these classes are new to the .Net Framework 4.5, you can still use this feature against older framework versions by creating your own classes in the System.Runtime.CompilerServices namespace.&#160; However, the feature will only work if the code calling the method is compiled with the C# 5 compiler; older compilers will ignore the attributes and simply pass the parameters’ default values.</p>  <p>All of the attributes can only be applied to arguments of types that have standard (not custom) implicit conversions to int or string.&#160; This means that it isn’t practical to overflow [CallerLineNumber] (the compiler ran out of memory first), so I can’t test how that behaves.</p>  <p>Using [CallerMemberName] on field initializers passes the field name, and on static or instances constructors passes the string <code>&quot;.cctor&quot;</code> or <code>&quot;.ctor&quot;</code> (as <a href="http://msdn.microsoft.com/en-us/library/hh534540%28VS.110%29.aspx#sectionToggle1">documented</a>)&#160; In indexers, it passes <code>&quot;Item&quot;</code>.</p>  <p>If a class has a constructor that takes only caller info attribute parameters, and you create another class that inherits it and does not declare a constructor (thus implicitly passing optional parameters), it passes the line number and file name of the class keyword in the derived class, but leaves the declared default for the member name (I suspect that’s a bug).&#160; </p>  <p>If you do declare a constructor, it passes the string <code>&quot;.ctor&quot;</code> as the member name for the implicit <code>base()</code> call (just like a normal method call from inside a constructor) and the line number of the beginning of the constructor declaration.&#160; If you actually write a <code>base()</code> call, it passes the line number of the <code>base</code> keyword.</p>  <p>If a call spans multiple lines, [CallerLineNumber] passes the line containing the openning parenthesis.</p>  <p>Delegates are fully supported; if you call a delegate that has an argumented annotated with a caller info attribute, the compiler will insert the correct value, regardless of the method you’re actually calling (which the compiler doesn’t even know).</p>  <p>LINQ query comprehension syntax is not supported at all; if you create a (for example) <code>Select()</code> method that contains a caller info attribute, then call it from a LINQ query (not lambda syntax), the compiler will crash (!).&#160; (they will fix that)</p>  <p>Expression trees do not support optional parameters at all, so that corner case is irrelevant.</p>  <p>Attributes are the most interesting story.&#160; What should happen if you declare a custom attribute that takes parameters with caller info attributes, then apply that attribute in various cases?&#160; This could potentially be very useful, since there is currently no way for an attribute to know what it’s being applied to. (I hadn’t thought of this usage when I wrote the original blog post)</p>  <p>The documentation <a href="http://msdn.microsoft.com/en-us/library/hh534540%28VS.110%29.aspx#sectionToggle1">says</a> that this will work in all cases, and that [CallerMemberName] will pass whatever the attribute is being applied to.&#160; However, in the beta build, this doesn’t always work.</p>  <p>Attributes applied to method arguments or return values do not pass any caller info at all.&#160; Attributes applied to types or generic type arguments do not pass member names (this is very disappointing)</p>  <p>Hopefully, those will be fixed before release.</p>  
</div>
{% endraw %}